--- KVIrc-master/src/kvilib/net/KviSSL.cpp.omv~	2017-10-06 00:06:55.933419153 +0200
+++ KVIrc-master/src/kvilib/net/KviSSL.cpp	2017-10-06 01:00:06.783342979 +0200
@@ -209,13 +209,14 @@ static DH * my_get_dh(int keylength)
 	dh = DH_new();
 	if(!dh)
 		return nullptr;
-	dh->p = BN_bin2bn(p, sp, nullptr);
-	dh->g = BN_bin2bn(g, sg, nullptr);
-	if((dh->p == nullptr) || (dh->g == nullptr))
+	BIGNUM *bp = BN_bin2bn(p, sp, nullptr);
+	BIGNUM *bg = BN_bin2bn(g, sg, nullptr);
+	if((bp == nullptr) || (bg == nullptr))
 	{
 		DH_free(dh);
 		return nullptr;
 	}
+	DH_set0_pqg(dh, bp, nullptr, bg);
 	return dh;
 }
 
@@ -695,7 +696,7 @@ int KviSSLCertificate::fingerprintDigest
 	if(!m_pX509)
 		return -1;
 
-	int NID = OBJ_obj2nid(m_pX509->sig_alg->algorithm);
+	int NID = X509_get_signature_nid(m_pX509);
 	if(NID == NID_undef)
 	{
 		return 0; // unknown digest function: it means the signature can't be verified: the certificate can't be trusted
@@ -710,7 +711,7 @@ int KviSSLCertificate::fingerprintDigest
 		return 0; // Unknown digest
 	}
 
-	return mdType->type;
+	return EVP_MD_type(mdType);
 }
 
 const char * KviSSLCertificate::fingerprintDigestStr()
@@ -829,7 +830,7 @@ void KviSSLCertificate::extractPubKeyInf
 	if(p)
 	{
 		m_iPubKeyBits = EVP_PKEY_bits(p);
-		m_szPubKeyType = (p->type == NID_undef) ? __tr("Unknown") : OBJ_nid2ln(p->type);
+		m_szPubKeyType = (EVP_PKEY_id(p) == NID_undef) ? __tr("Unknown") : OBJ_nid2ln(EVP_PKEY_id(p));
 		//		getPKeyType(p->type,m_szPubKeyType);
 	}
 	else
@@ -852,17 +853,25 @@ void KviSSLCertificate::extractSignature
 {
 	static char hexdigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
 
-	int i = OBJ_obj2nid(m_pX509->sig_alg->algorithm);
+	int i = X509_get_signature_nid(m_pX509);
 	m_szSignatureType = (i == NID_undef) ? __tr("Unknown") : OBJ_nid2ln(i);
 
 	m_szSignatureContents = "";
 
-	for(i = 0; i < m_pX509->signature->length; i++)
+	ASN1_BIT_STRING const *sig;
+	X509_ALGOR const *alg;
+	X509_get0_signature(&sig, &alg, m_pX509);
+
+	if (sig == nullptr)
+		return;
+
+	const unsigned char *sign = ASN1_STRING_get0_data(sig);
+	for(i = 0; i < ASN1_STRING_length(sig); i++)
 	{
 		if(m_szSignatureContents.hasData())
 			m_szSignatureContents.append(":");
-		m_szSignatureContents.append(hexdigits[(m_pX509->signature->data[i] & 0xf0) >> 4]);
-		m_szSignatureContents.append(hexdigits[(m_pX509->signature->data[i] & 0x0f)]);
+		m_szSignatureContents.append(hexdigits[(sign[i] & 0xf0) >> 4]);
+		m_szSignatureContents.append(hexdigits[(sign[i] & 0x0f)]);
 	}
 }
 
--- KVIrc-master/src/modules/file/libkvifile.cpp.omv~	2017-10-06 01:07:24.527437926 +0200
+++ KVIrc-master/src/modules/file/libkvifile.cpp	2017-10-06 01:08:58.659518648 +0200
@@ -1553,7 +1553,7 @@ static bool file_kvs_fnc_digest(KviKvsMo
 	if(szAlgo.isEmpty())
 		szAlgo = "md5";
 
-	EVP_MD_CTX mdctx;
+	EVP_MD_CTX *mdctx = EVP_MD_CTX_new();
 	const EVP_MD * pMD;
 	unsigned char ucMDValue[EVP_MAX_MD_SIZE];
 	unsigned int uMDLen, u;
@@ -1567,11 +1567,11 @@ static bool file_kvs_fnc_digest(KviKvsMo
 		return true;
 	}
 
-	EVP_MD_CTX_init(&mdctx);
-	EVP_DigestInit_ex(&mdctx, pMD, nullptr);
-	EVP_DigestUpdate(&mdctx, content.constData(), content.size());
-	EVP_DigestFinal_ex(&mdctx, ucMDValue, &uMDLen);
-	EVP_MD_CTX_cleanup(&mdctx);
+	EVP_MD_CTX_init(mdctx);
+	EVP_DigestInit_ex(mdctx, pMD, nullptr);
+	EVP_DigestUpdate(mdctx, content.constData(), content.size());
+	EVP_DigestFinal_ex(mdctx, ucMDValue, &uMDLen);
+	EVP_MD_CTX_free(mdctx);
 
 	for(u = 0; u < uMDLen; u++)
 	{
--- KVIrc-master/src/modules/fish/libkvifish.cpp.omv~	2017-10-06 01:09:42.982638541 +0200
+++ KVIrc-master/src/modules/fish/libkvifish.cpp	2017-10-06 01:15:03.813740322 +0200
@@ -81,25 +81,25 @@ static bool fish_DH1080_gen(unsigned cha
 	if(!g_fish_dh)
 	{
 		BIGNUM * dhp = BN_new();
-		BN_init(dhp);
 		if(!BN_hex2bn(&dhp, g_fish_prime1080_hex))
 			return false;
 
 		BIGNUM * dhg = BN_new();
-		BN_init(dhg);
 		if(!BN_hex2bn(&dhg, g_fish_generator))
 			return false;
 
 		g_fish_dh = DH_new();
-		g_fish_dh->p = dhp;
-		g_fish_dh->g = dhg;
+		DH_set0_pqg(g_fish_dh, dhp, nullptr, dhg);
 
 		DH_generate_key(g_fish_dh);
 	}
 
-	*iLen = BN_num_bytes(g_fish_dh->pub_key);
+	const BIGNUM *pubkey;
+	DH_get0_key(g_fish_dh, &pubkey, nullptr);
+
+	*iLen = BN_num_bytes(pubkey);
 	*szPubKey = (unsigned char *)KviMemory::allocate(*iLen);
-	BN_bn2bin(g_fish_dh->pub_key, *szPubKey);
+	BN_bn2bin(pubkey, *szPubKey);
 
 	return true;
 #else
--- KVIrc-master/src/modules/str/libkvistr.cpp.omv~	2017-10-06 01:23:56.215078226 +0200
+++ KVIrc-master/src/modules/str/libkvistr.cpp	2017-10-06 01:25:10.947673538 +0200
@@ -1383,7 +1383,7 @@ static bool str_kvs_fnc_digest(KviKvsMod
 	if(szType.isEmpty())
 		szType = "md5";
 
-	EVP_MD_CTX mdctx;
+	EVP_MD_CTX * mdctx = EVP_MD_CTX_new();
 	const EVP_MD * md;
 	unsigned char md_value[EVP_MAX_MD_SIZE];
 	unsigned int md_len, i;
@@ -1397,11 +1397,11 @@ static bool str_kvs_fnc_digest(KviKvsMod
 		return true;
 	}
 
-	EVP_MD_CTX_init(&mdctx);
-	EVP_DigestInit_ex(&mdctx, md, nullptr);
-	EVP_DigestUpdate(&mdctx, szString.toUtf8().data(), szString.toUtf8().length());
-	EVP_DigestFinal_ex(&mdctx, md_value, &md_len);
-	EVP_MD_CTX_cleanup(&mdctx);
+	EVP_MD_CTX_init(mdctx);
+	EVP_DigestInit_ex(mdctx, md, nullptr);
+	EVP_DigestUpdate(mdctx, szString.toUtf8().data(), szString.toUtf8().length());
+	EVP_DigestFinal_ex(mdctx, md_value, &md_len);
+	EVP_MD_CTX_free(mdctx);
 
 	for(i = 0; i < md_len; i++)
 	{
@@ -2314,7 +2314,7 @@ static bool str_kvs_fnc_evpSign(KviKvsMo
 #if defined(COMPILE_SSL_SUPPORT)
 
 	KviSSL::globalSSLInit();
-	EVP_MD_CTX md_ctx;
+	EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();
 	EVP_PKEY * pKey = nullptr;
 	unsigned int len = 0;
 	unsigned char * sig = nullptr;
@@ -2368,9 +2368,9 @@ static bool str_kvs_fnc_evpSign(KviKvsMo
 	len = EVP_PKEY_size(pKey);
 	sig = (unsigned char *)KviMemory::allocate(len * sizeof(char));
 
-	EVP_SignInit(&md_ctx, EVP_sha1());
-	EVP_SignUpdate(&md_ctx, (unsigned char *)szMessage.data(), szMessage.length());
-	if(EVP_SignFinal(&md_ctx, sig, &len, pKey))
+	EVP_SignInit(md_ctx, EVP_sha1());
+	EVP_SignUpdate(md_ctx, (unsigned char *)szMessage.data(), szMessage.length());
+	if(EVP_SignFinal(md_ctx, sig, &len, pKey))
 	{
 		QByteArray szSign((const char *)sig, len);
 		OPENSSL_free(sig);
@@ -2451,7 +2451,7 @@ static bool str_kvs_fnc_evpVerify(KviKvs
 	szSign = QByteArray::fromBase64(szSignB64);
 	const char * message = szMessage.data();
 
-	EVP_MD_CTX md_ctx;
+	EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();
 	EVP_PKEY * pKey = nullptr;
 	X509 * cert = nullptr;
 	int err = -1;
@@ -2518,10 +2518,10 @@ static bool str_kvs_fnc_evpVerify(KviKvs
 		}
 	}
 
-	EVP_VerifyInit(&md_ctx, EVP_sha1());
-	EVP_VerifyUpdate(&md_ctx, message, strlen(message));
-	err = EVP_VerifyFinal(&md_ctx, (unsigned char *)szSign.data(), szSign.size(), pKey);
-	EVP_MD_CTX_cleanup(&md_ctx);
+	EVP_VerifyInit(md_ctx, EVP_sha1());
+	EVP_VerifyUpdate(md_ctx, message, strlen(message));
+	err = EVP_VerifyFinal(md_ctx, (unsigned char *)szSign.data(), szSign.size(), pKey);
+	EVP_MD_CTX_free(md_ctx);
 	EVP_PKEY_free(pKey);
 	switch(err)
 	{
